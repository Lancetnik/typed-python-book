# Словарь с Literal ключами

Плюс в описанном выше словаре ключом является строка, получается — любая строка? Но нет,  в реальности не любая, а только одна из двух строк — `longitude` или `latitude`. Это можно отразить в type hinting с помощью `Literal`:

```python
from typing import Literal

def get_gps_coordinates() -> dict[Literal["longitude"] | Literal["latitude"], float]:
    return {"longitude": 10, "latitude": 20}

print(
    get_gps_coordinates()["longitude"]
)

print(
    get_gps_coordinates()["longitudeRRR"]  # Тут IDE покажет ошибку!
)
```

`Literal` позволяет указать не просто какой-то тип вроде `str`, а позволяет указать конкретное значение этого типа. В данном случае у нас ключом может быть либо строка со значением `"longitude"`, либо строка со значением `"latitude"`.

Вот эта вертикальная черта обозначает ИЛИ, то есть или тип слева от черты, или тип справа от черты. Это синтаксис Python 3.10, в предыдущих версиях Python нужно было импортировать из `typing` специальный тип `Union`, который делал то же самое. Сейчас можно просто пользоваться вертикальной чертой для того, чтобы задать несколько возможных типов для переменной.

В случае именно `Literal` для указания нескольких возможных значений можно обойтись без объединения нескольких типов через вертикальную черту и задать тип следующим образом:

```python
def get_gps_coordinates() -> dict[Literal["longitude", "latitude"], float]:
    return {"longitude": 10, "latitude": 20}
```

А если тип переменной представляет из себя, например, число или строку, тогда эти типы объединяются через вертикальную черту:

```python
age: int | str
```

Кстати, *literally* — по-русски означает «буквально». То есть, когда нам надо буквально задать конкретные значения в типе, мы можем это сделать при помощи типа `Literal`.

В целом в таком формате использовать словарь здесь можно, но мне больше нравится вариант с именованным кортежем из этих двух вариантов.
